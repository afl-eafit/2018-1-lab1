<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Constructing a suffix automaton</title>
  </head>

  <body>
    <h1 style="text-align:center;">Programming Lab 1: Constructing a
    Suffix Automaton</h1>

    <h3>TA: Andrés Ortega</h3>

    <h3>News</h3>

    <p>(2018-03-04) There was an error on the example of the
    <code>differentSubstrings</code> function. The example did not
    include the empty string. The example was fixed. Thanks to
    Alejandro Rojas Benitez for pointing out the error.</p>

    <h3>Introduction</h3>

    <p>"The <i>suffix automaton</i> of a word <i>x</i> is defined as
    the minimal deterministic (non necessarily complete) automaton
    that recognizes the (finite) set of suffixes of <i>x</i>"
    [Crochemore and Hancart 1997, p. 434]. With this automaton one can easily
    answer a wide range of string problems such as locating all
    ocurrences of any word <i>y</i> in <i>x</i>, how many times such
    <i>y</i> occurs in <i>x</i>, the longest prefix of <i>y</i> that
    is a substring of <i>x</i>, the longest substring of <i>x</i> that
    occurs twice in <i>x</i> and much more [Crochemore and Hancart
    1997]. The flexibility on the type of problems that can be
    approached with a suffix automaton and its low computational
    complexity make it a useful tool when working with strings in
    general.</p>

    <h3>Assignment (80%)</h3>

    <ul>
      <li>Download the<a href="https://github.com/"> GitHub </a>
      repository <a href=
      "https://github.com/afl-eafit/2018-1-lab1">2018-1-lab1</a>.</li>

      <li>(70%) Using the data types in the above repository and using
        a <i>suffix automaton</i> define 4 functions:
	<pre>
	  differentSubstrings :: String -> Int
	</pre>
	that takes a string <code>xs</code> and returns an integer
	that is the number of different substrings present in
	<code>xs</code> (including the empty string).

        <pre>
	  countAppearances :: String -> String -> Int
	</pre>
	that takes two strings <code>xs</code> and <code>ys</code> and
	returns an integer that is the number of times <code>xs</code>
	appears in <code>ys</code>. Be wary that overlapping
	occurrences count individually.

        <pre>
	  isSuffix :: String -> String -> Bool
	</pre>
	that takes two strings <code>xs</code> and <code>ys</code> and
	returns <code>True</code> if <code>xs</code> is a suffix of
	<code>ys</code> and <code>False</code> otherwise. The empty
	string is considered a suffix of every string.

        <pre>
	  isSubstring :: String -> String -> Bool
	</pre>
	that takes two strings <code>xs</code> and <code>ys</code> and
	returns <code>True</code> if there exist at least one
	appearance of <code>xs</code> in <code>ys</code> and
	<code>False</code> otherwise.

      </li>

      <li>(10%)
      <ul>
	<li>Your lab will be tested using the <code>-Wall</code>,
	<code>-Wmissing-local-signatures</code> and
	<code>-Wmissing-signatures</code> options.</li>

	<li>Annotate (in English) your source code using
	  <a href="http://hackage.haskell.org/package/haddock">Haddock</a>.
	  Documentation should explain your solution for the assignment.</li>

	<li>Improve your implementation with
	  <a href="https://github.com/ndmitchell/hlint">HLint</a>.
	</li>
      </ul>
      </li>
    </ul>

    <h3>Examples</h3>
    <p>Using the <code>Examples.hs</code> module in above GitHub
    repository, this is what a sample input-output looks like:</p>

    <pre>
      GHCi> differentSubstrings "aabaa"
      12
      GHCi> countAppearances "aa" "aaa"
      2
      GHCi> isSuffix "abc" "aaaabcccc"
      False
      GHCi> isSubstring "abc" "aaaabcccc"
      True
    </pre>

    <h3>Clean code (10%)</h3>

    <p>Before submitting your code, which includes your README, clean it
    up! Clean code:</p>

    <ul>
      <li>Does not have long lines (at most 80 columns).</li>

      <li>Has an uniformly indentation (we recommended two
      characters).</li>

      <li>Has a consistent layout.</li>

      <li>Has type signatures for everything (included
      <code>where</code>-clauses and
      <code>let</code>-definitions).</li>

      <li>Has no junk (unused code, commented code, unnecessary
      code).</li>

      <li>Has no overly complicated function definitions.</li>

      <li>Does not contain any repetitive code.</li>

      <li>Has no tabs.</li>

      <li>Has no unnecessary spaces at the end of a line, or empty
      lines at the end of a file. (See:
	<a href="http://www1.eafit.edu.co/asr/tips-and-tricks.html#
		 fixing-trailing-whitespace-issues">
	  Fixing trailing whitespace issues with Emacs </a>).
      </li>

      <li>Has spell-checked comments.</li>
    </ul>


    <h3>Notes</h3>

    <ul>
    <li>The programming lab may either be solved on your own, or
    jointly with one other student taking the course.</li>

    <li>You are to use GHC[i] ≥ 8.2.2.</li>
    </ul>

    <h3>Submission (10%)</h3>

    <p>Submission is electronic. Send an email to
    <tt>asr(at)eafit(dot)edu(dot)co</tt> and
    <tt>aortega7(at)eafit(dot)edu(dot)co</tt> and attach a compressed
    file (.zip or .tar.gz) with your solution.</p>

    <p>Your submission has to include the following:</p>

    <ul>
      <li><tt>SuffixAutomaton.hs</tt>, a Haskell module file with your solution
      for the assignment.</li>

      <li>
	<tt>README</tt> (or <tt>README.md</tt>), a file (in English)
	containing at least the following information:

	<ul>
	  <li>The name of your program</li>

	  <li>Your name(s)</li>

	  <li>A general description of your program</li>

	  <li>Information on how to use your program</li>

	  <li>GHC and/or Haskell platform versions used</li>
	</ul>
      </li>

      <li>Do not include any other files.</li>
    </ul>

    <h3>Bibliography</h3>
    <ul>
      <li>Maxime Crochemore, Christophe Hancart (1997). Automata for
      Matching Patterns. Rozenberg G., Salomaa A. Handbook of Formal
      Languages, 2, Linear Modeling: Background and Application,
      Springer-Verlag, pp. 399-462. <a
      href="https://doi.org/10.1007/978-3-662-07675-0_9">DOI</a>. Version
      available at <a
      href="https://hal-enpc.archives-ouvertes.fr/hal-00620792/">
      HAL</a>.
      </li>
    </ul>

    <hr/>

    <table style="width:100%">
      <tr>
	<td><a href=
	"http://www1.eafit.edu.co/asr/courses/automata-CM0081/">Automata
	and formal languages - CM0081</a></td>

	<td style="text-align:right;"><a
	href="http://validator.w3.org/check?uri=referer"><img
	src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML
	1.1" height="31" width="88" /></a></td>
      </tr>
    </table>
  </body>
</html>
